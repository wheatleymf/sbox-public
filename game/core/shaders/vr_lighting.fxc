// Copyright (c) Valve Corporation, All rights reserved. ======================================================================================================

#ifndef VR_LIGHTING_FXC
#define VR_LIGHTING_FXC

#include "system.fxc"
#include "common_samplers.fxc" // Move me
#include "light_probe_volume.fxc"
#include "baked_lighting_constants.fxc"
#include "pcss.fxc"
#include "common/lightbinner.hlsl"

//-------------------------------------------------------------------------------------------------------------------------------------------------------------

Texture2D g_tBlueNoise : register(t0) < Attribute("BlueNoise"); > ;

//-------------------------------------------------------------------------------------------------------------------------------------------------------------

#include "common/classes/_classes.hlsl"
#include "common/BRDF.hlsl"
#include "common/DDGI/DDGI.hlsl"

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// Debug visualization
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
bool g_bShowLightmapTexels < Attribute( "g_bShowLightmapTexels" ); >;
bool g_bShowLPVVoxels < Attribute( "g_bShowLPVVoxels" ); >;

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// Subsurface scattering
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
#if ( S_SUBSURFACE_SCATTERING )

	#define SSS_CURVATURE_MIN ( 1.0 / 39.3701 ) // 100 cm = 39.3701 inch
	#define SSS_CURVATURE_MAX ( 1.0 / 0.393701 ) // 1 cm = 0.393701 inch
	#define SSS_CURVATURE_SCALE ( 1.0 / ( SSS_CURVATURE_MAX - SSS_CURVATURE_MIN ) )
	#define SSS_CURVATURE_BIAS ( -SSS_CURVATURE_MIN * SSS_CURVATURE_SCALE )

	CreateInputTexture2D( TextureDiffuseFalloff, Srgb, 8, "", "_diffusewarp", "Lookup Textures", Default3AndFile( 0.5, 0.5, 0.5, "materials/default/default_skin_diffusewarp.tga" ) );
	Texture2D g_tDiffuseFalloff < Channel( RGB, Box( TextureDiffuseFalloff ), Srgb );
										   OutputFormat( RGBA8888 );
										   SrgbRead( false ); >;

	float3 g_vAmbientNormalSoftness < UiType( Color ); Default3( 1.0, 0.3, 0.0 ); UiGroup( "Lookup Textures" ); >;

#endif

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// Transmissive Wrap parameters. This could be exposed to the material author.
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
#define TRANSMISSIVE_WRAP 1.0
#define TRANSMISSIVE_EXPONENT 1.0
#define TRANSMISSIVE_WRAP_PARAMETERS float4( TRANSMISSIVE_WRAP, TRANSMISSIVE_EXPONENT, 1.0 / ( 1.0 + TRANSMISSIVE_WRAP ), ( 1.0 + TRANSMISSIVE_EXPONENT ) / ( 2.0 + 2.0 * TRANSMISSIVE_WRAP ) )
#define TRANSMISSIVE_SHADOW_MASK_BIAS 24.0 // Any potential light blockers, up to this bias value, will need to test whether or not they transmit light

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// Self shadow normal maps
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
#if ( S_ENABLE_NORMAL_SELF_SHADOW )
float g_flLightRangeForSelfShadowNormals < Default( 0.707 ); Range( 0.0, 1.0 ); UiGroup( "Normal" ); >;
#endif

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
struct LightingTerms_t
{
	float3 vDiffuse;
	float3 vSpecular;
	float3 vIndirectDiffuse;
	float3 vIndirectSpecular;
	float3 vTransmissive;
	float flBakedAmbientOcclusion;
	float flDynamicAmbientOcclusion;

};

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
LightingTerms_t InitLightingTerms()
{
	LightingTerms_t o;

	o.vDiffuse.rgb = float3( 1.0, 1.0, 1.0 );
	o.vSpecular.rgb = float3( 0.0, 0.0, 0.0 );
	o.vIndirectDiffuse.rgb = float3( 0.0, 0.0, 0.0 );
	o.vIndirectSpecular.rgb = float3( 0.0, 0.0, 0.0 );
	o.vTransmissive.rgb = float3( 0.0, 0.0, 0.0 );
	o.flBakedAmbientOcclusion = 1.0;
	o.flDynamicAmbientOcclusion = 1.0;

	return o;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
LightingTerms_t InitLightingTerms( float3 vPerVertexTransmissive )
{
	LightingTerms_t o = InitLightingTerms();
	o.vTransmissive.rgb = vPerVertexTransmissive.rgb;
	return o;
}

//---------------------------------------------------------------------------------------------------------------------------------------------------------
float WrapNdotL( float flNdotL, float4 vSSSWrapParameters )
{
	float flWrapNDotL = flNdotL;
	flWrapNDotL += vSSSWrapParameters.x; // W
	flWrapNDotL *= vSSSWrapParameters.z; // 1.0 + W
	flWrapNDotL = ClampToPositive( flWrapNDotL );
	flWrapNDotL = pow( flWrapNDotL, vSSSWrapParameters.y ); // N
	flWrapNDotL *= vSSSWrapParameters.w; // ( N + 1.0 ) / ( 2.0 + 2.0 * W )
	return flWrapNDotL;
}

//---------------------------------------------------------------------------------------------------------------------------------------------------------
float OpaqueFade( float flOpacity, float4 vPositionSs )
{
	float flWidth = 1.0 / g_nMSAASampleCount;
	float flNoise = g_tBlueNoise.Load( int3( vPositionSs.xy % TextureDimensions2D( g_tBlueNoise, 0 ).xy, 0 ) ).g;
	return lerp( -flWidth, 1.0, flOpacity ) + flWidth * flNoise;
}

//---------------------------------------------------------------------------------------------------------------------------------------------------------
void OpaqueFadeDepth( float flOpacity, float2 vPositionSs )
{
	float flNoise = g_tBlueNoise.Load( int3( vPositionSs.xy % TextureDimensions2D( g_tBlueNoise, 0 ).xy, 0 ) ).g;
	clip( mad( flOpacity, 2.0, -1.5 ) + flNoise );
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
float GetLightmapUVCheckerboard( float2 vUV )
{
	int2 vDims = TextureDimensions2DArray( LightMap( 2 ), 0 );
	int2 vUVInPixels = int2( vUV.xy * vDims.xy );
	if ( ( ( vUVInPixels.x + vUVInPixels.y ) & 1 ) == 1 )
		return 0.8f;
	return 1.2f;
}


//---------------------------------------------------------------------------------------------------------------------------------------------------------
void ComputeDiffuseAndSpecularTerms( out float3 o_vDiffuseTerm, out float3 o_vSpecularTerm, out float3 o_vTransmissiveTerm,
									 bool bDiffuse, bool bSpecular, bool bTransmissive,
									 const FinalCombinerInput_t f,
									 float3 vPositionToLightDirWs, float3 vPositionToCameraDirWs,
									 float2 vDiffuseExponent,
									 float flNDotL )
{
	float3 vNormalWs = f.vNormalWs.xyz;

	// Gets rid of bumps as light direction becomes more grazing
	#if ( S_ENABLE_NORMAL_SELF_SHADOW )
	{
		float flDot = dot( vPositionToLightDirWs.xyz, f.vNormalWs.xyz ) * ( 1.0 / g_flLightRangeForSelfShadowNormals );
		vNormalWs.xyz = lerp( f.vNormalWs.xyz, vNormalWs.xyz, saturate( flDot ) );
		vNormalWs.xyz = normalize( vNormalWs.xyz );
	}
	#endif

	// Diffuse
	o_vDiffuseTerm = float3( 0.0, 0.0, 0.0 );
	if ( bDiffuse )
	{
		if ( g_bNonDirectionalDiffuseLighting )
		{
			o_vDiffuseTerm.rgb = 1.0;
		}
		else
		{
			#if ( S_SUBSURFACE_SCATTERING == SUBSURFACE_SCATTERING_PREINTEGRATED )
			{
				float flSSSCurvatureScaled = f.flSSSCurvature * SSS_CURVATURE_SCALE + SSS_CURVATURE_BIAS;
				float flNDotLBlurredUnclamped = dot( f.vSSSNormalWs.xyz, vPositionToLightDirWs.xyz );
				float2 vCurvatureLUTUv = float2( mad( flNDotLBlurredUnclamped, 0.5, 0.5 ), flSSSCurvatureScaled );
				float3 vCurvatureRGB = Tex2DLevelS( g_tDiffuseFalloff, g_sTrilinearClamp, vCurvatureLUTUv.xy, 0.0 ).rgb * float3( 0.5, 0.5, 0.5 ) - float3( 0.25, 0.25, 0.25 );
				float3 vNormalSmoothFactor = saturate( 1.0 - flNDotLBlurredUnclamped.xxx );
				vNormalSmoothFactor.rgb *= vNormalSmoothFactor.rgb;
				float3 vNormalShadeG = normalize( lerp( vNormalWs.xyz, f.vSSSNormalWs.xyz, 0.3 + 0.7 * vNormalSmoothFactor.xyz ) );
				float3 vNormalShadeB = normalize( lerp( vNormalWs.xyz, f.vSSSNormalWs.xyz, 0.0 + 1.0 * vNormalSmoothFactor.xyz ) );
				float flNDotLShadeG = saturate( dot( vNormalShadeG.xyz, vPositionToLightDirWs.xyz ) );
				float flNDotLShadeB = saturate( dot( vNormalShadeB.xyz, vPositionToLightDirWs.xyz ) );
				float3 vNDotL = float3( saturate( flNDotLBlurredUnclamped ), flNDotLShadeG, flNDotLShadeB );
				o_vDiffuseTerm.rgb = saturate( vNDotL.rgb + vCurvatureRGB.rgb );
				o_vDiffuseTerm.rgb = lerp( flNDotL.xxx, o_vDiffuseTerm.rgb, f.flSSSMask );
			}
			#elif ( S_SUBSURFACE_SCATTERING == SUBSURFACE_SCATTERING_WRAP )
			{
				float flNdotL = dot( f.vSSSNormalWs.xyz, vPositionToLightDirWs.xyz );
				float flWrapNdotL = WrapNdotL( flNdotL, f.vSSSWrapParameters.xyzw );
				o_vDiffuseTerm.rgb = lerp( saturate( flNdotL ).xxx, flWrapNdotL.xxx, f.vSSSWrapColor.rgb );
				o_vDiffuseTerm.rgb = lerp( flNDotL.xxx, o_vDiffuseTerm.rgb, f.flSSSMask );
			}
			#else
			{
				float flDiffuseExponent = ( vDiffuseExponent.x + vDiffuseExponent.y ) * 0.5;
				o_vDiffuseTerm.rgb = pow( flNDotL, flDiffuseExponent ) * ( ( flDiffuseExponent + 1.0 ) * 0.5 ).xxx;
			}
			#endif
		}
	}

	// Specular
	o_vSpecularTerm = float3( 0.0, 0.0, 0.0 );
	[branch] if ( bSpecular )
	{
		float3 vHalfAngleDirWs = normalize( vPositionToLightDirWs.xyz + vPositionToCameraDirWs.xyz );

		#if ( S_RETRO_REFLECTIVE )
		{
			//
			// Use "back vector" instead of the half vector
			//
			float3 vReflectionDirWs = reflect( vPositionToCameraDirWs.xyz, vNormalWs.xyz );
			vHalfAngleDirWs = normalize( lerp( vHalfAngleDirWs.xyz, vPositionToLightDirWs.xyz - vReflectionDirWs.xyz, f.flRetroReflectivity ) );
		}
		#endif

		float flNdotH = dot( vHalfAngleDirWs.xyz, vNormalWs.xyz );
		float flXdotH = dot( vHalfAngleDirWs.xyz, f.vPerPixelTangentUWs.xyz );
		float flYdotH = dot( vHalfAngleDirWs.xyz, f.vPerPixelTangentVWs.xyz );
		float flNdotV = ClampToPositive( dot( vNormalWs.xyz, vPositionToCameraDirWs.xyz ) );
		float flVdotH = ClampToPositive( dot( vPositionToCameraDirWs.xyz, vHalfAngleDirWs.xyz ) );

		float flSpecularTerm = 0.0;
		#if ( S_CLOTH_SHADING )
		{
			float flIsotropicRoughness = IsotropicRoughnessFromAnisotropicRoughness( f.vRoughness.xy );
			flSpecularTerm = ComputeCharlieSheenBRDF( flIsotropicRoughness, flNDotL, flNdotV, flNdotH );
			flSpecularTerm *= flNDotL;
		}
		#elif ( S_ANISOTROPIC_GLOSS ) // Adds 34 asm instructions compared to isotropic spec in #else below
		{
			flSpecularTerm = ComputeGGXAnisoBRDF( f.vRoughness.xy, flNDotL, flNdotV, flNdotH, flXdotH, flYdotH, flVdotH, f.vPositionSs.xy );
			flSpecularTerm *= flNDotL;
		}
		#elif ( S_TWO_LOBE_SPECULAR )
		{
			// Lerp between two specular terms
			float2 vSpecularTerm = ComputeGGXBRDF( f.vRoughness.xy, flNDotL, flNdotV, flNdotH, f.vPositionSs.xy ).xy;
			flSpecularTerm = lerp( vSpecularTerm.x, vSpecularTerm.y, f.flTwoLobeSpecularRatio );
			flSpecularTerm *= flNDotL;
		}
		#else
		{
			flSpecularTerm = ComputeGGXBRDF( f.vRoughness.xx, flNDotL, flNdotV, flNdotH, f.vPositionSs.xy ).x;
			flSpecularTerm *= flNDotL;
		}
		#endif

		float flFresnelEdge = 1.0; // Might want to control this from the caller later, so I'm leaving the variable in place for now

		float flLDotH = ClampToPositive( dot( vPositionToLightDirWs.xyz, vHalfAngleDirWs.xyz ) );
		float3 vFresnel = f.vSpecularColor + ( ( 1.0 - f.vSpecularColor ) * flFresnelEdge * pow( 1.0 - flLDotH, f.flFresnelExponent ) );

		o_vSpecularTerm.rgb = vFresnel * flSpecularTerm;
	}

	o_vTransmissiveTerm.rgb = float3( 0.0, 0.0, 0.0 );
	#if ( S_TRANSMISSIVE_BACKFACE_NDOTL || S_TRANSMISSIVE )
	{
		float flBackfaceNdotL = ClampToPositive( -dot( f.vNormalWs.xyz, vPositionToLightDirWs.xyz ) );
		o_vTransmissiveTerm.rgb = flBackfaceNdotL.xxx;
	}
	#endif
}

//---------------------------------------------------------------------------------------------------------------------------------------------------------
void ComputeDiffuseAndSpecularTerms( out float3 o_vDiffuseTerm, out float3 o_vSpecularTerm, out float3 o_vTransmissiveTerm,
                                    bool bDiffuse, bool bSpecular, bool bTransmissive,
                                    const FinalCombinerInput_t f,
                                    float3 vPositionToLightDirWs, float3 vPositionToCameraDirWs,
                                    float2 vDiffuseExponent )
{
    float3 vNormalWs = f.vNormalWs.xyz;
    float flNDotL = ClampToPositive( dot( vNormalWs.xyz, vPositionToLightDirWs.xyz ) );
    ComputeDiffuseAndSpecularTerms( o_vDiffuseTerm, o_vSpecularTerm, o_vTransmissiveTerm, bDiffuse, bSpecular, bTransmissive, f, vPositionToLightDirWs, vPositionToCameraDirWs, vDiffuseExponent, flNDotL );
}

//---------------------------------------------------------------------------------------------------------------------------------------------------------
float3 ComputePerVertexTransmissiveLighting( float3 vPositionWs, float3 vNormalWs, float3 vTransmissionFalloffCoefficient, float flMinThickness )
{
	float3 vTransmissiveLighting = float3( 0.0, 0.0, 0.0 );
	float3 vPositionWithOffsetWs = vPositionWs.xyz - g_vHighPrecisionLightingOffsetWs.xyz;

	return vTransmissiveLighting.rgb;
}


//---------------------------------------------------------------------------------------------------------------------------------------------------------

float3 ComputeTransmissiveThickness(
							   const FinalCombinerInput_t f,
							   const BinnedLight l,
							   float3 vPositionTextureSpace,
							   float3 vPositionToLightDirWs )
{
	#if ( S_TRANSMISSIVE )
	{
		[branch] if ( any( f.vTransmissiveMask.rgb ) )
		{
			float3 vTransmit = float3( 0.367879, 0.367879, 0.367879 ); // exp( -1.0 )

			float flLinearDepth =  ComputeShadow_ProjectiveDepthToLinearDepth( vPositionTextureSpace.z, l.ProjectedShadowDepthToLinearDepth.xyzw );
			float flBlockerDepthPs = ComputeShadow_MinDepth_1x1( vPositionTextureSpace.xyz );
			float flBlockerLinearDepth = ComputeShadow_ProjectiveDepthToLinearDepth( flBlockerDepthPs, l.ProjectedShadowDepthToLinearDepth.xyzw );
			float3 vThickness = f.vTransmissiveFalloff * max( flLinearDepth - flBlockerLinearDepth, 1.0 );
            vTransmit = exp(-vThickness.rgb * vThickness.rgb);
            return vTransmit;
		}
	}
	#endif

    // No transmissive
    return 0.0f;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// Todo: Make this single path for everything? This is much nicer, and LTC makes this pretty cheap
// Missing: Transmissive, Anisotropic, Two Lobe Specular, Cloth Shading BRDF
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
void ComputeDirectLightingForAreaLight( const FinalCombinerInput_t f, const BinnedLight lightData, inout float3 vDiffuse, inout float3 vSpecular, inout float3 vTransmissive, float flFalloff = 1.0f, bool bBaked = false )
{
	float3 vPositionToCameraDirWs = CalculatePositionToCameraDirWs( f.vPositionWs.xyz);
	float flRoughness = IsotropicRoughnessFromAnisotropicRoughness( f.vRoughness.xy );
	float flNDotV					= ClampToPositive( dot( vPositionToCameraDirWs.xyz, f.vNormalWs.xyz ) );
	float3 vBRDF = CalcBRDFReflectionFactor( flNDotV, flRoughness, f.vSpecularColor);
	float flShadow = 1.0f; // Not yet

	if( lightData.IsDiffuseEnabled()  )
	{
		vDiffuse += !bBaked ? ( LTC::Contribution(
							lightData,                          // Light data
							f.vPositionWs.xyz,                  // World-space position (P)
							f.vNormalWs.xyz,                    // World-space normal (N)
							normalize(vPositionToCameraDirWs),  // World-space view direction (V)
							flRoughness,                     // Material roughness parameter
							false
		) * flShadow * flFalloff ) : lightData.GetColor();
	}

	if( lightData.IsSpecularEnabled() )
	{
        vSpecular += LTC::Contribution(
                         lightData,                         // Light data
                         f.vPositionWs.xyz,                 // World-space position (P)
                         f.vNormalWs.xyz,                   // World-space normal (N)
                         normalize(vPositionToCameraDirWs), // World-space view direction (V)
                         flRoughness,                       // Material roughness parameter
                         true
		) * flShadow * flFalloff * vBRDF;
	}
	
	// Todo: Transmissive
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------
void ComputeDirectLightingForLight( const FinalCombinerInput_t f, const BinnedLight lightData, inout float3 vDiffuse, inout float3 vSpecular, inout float3 vTransmissive, bool bBaked = false )
{
	const float2 vDiffuseExponent = ( ( 1.0 - f.vRoughness.xy ) * 0.8 ) + 0.6; // 0.8 and 0.6 are magic numbers;

	float3 vLightColor		= lightData.GetColor();
	float3 vLightPositionWs = lightData.GetPosition();
	float3 vPositionToLightRayWs = vLightPositionWs - f.vPositionWs.xyz; // "L"
	float3 vPositionToCameraDirWs = CalculatePositionToCameraDirWs( f.vPositionWs.xyz);

	float3 vPositionToLightDirWs = normalize(vPositionToLightRayWs.xyz);

	float flDistToLightSq = dot( vPositionToLightRayWs.xyz, vPositionToLightRayWs.xyz );
	float flNDotL = ClampToPositive( dot( f.vNormalWs.xyz, vPositionToLightDirWs.xyz ) );

	if ( flDistToLightSq > lightData.GetRadiusSquared() && !bBaked ) // .z stores radius squared of light
	{
		// Outside light range
		return;
	}

	float flOuterConeCos = lightData.SpotLightInnerOuterConeCosines.y;
	float flConeToDirection = dot( vPositionToLightDirWs.xyz, -lightData.GetDirection() ) - flOuterConeCos;
	if ( flConeToDirection <= 0.0 && !bBaked )
	{
		// Outside spotlight cone
		return;
	}
	
	bool isAreaLight = lightData.GetShapeSize().x > 1.0f;
	if( isAreaLight )
    {
		// We do some weird math for falloff calculation in lightdesc for point lights, we only want the truncation value of this for area lights since
		// LTC already does falloff by itself, this approximates the falloff value correctly, soon should use barn lights system without this bs
		const float flAreaFalloff = ( lightData.FalloffParams.w * ( lightData.GetRadiusSquared() / 10000.0f ) ) * ( 1.0 - ( flDistToLightSq / lightData.GetRadiusSquared() ) );

        ComputeDirectLightingForAreaLight(f, lightData, vDiffuse, vSpecular, vTransmissive, flAreaFalloff, bBaked );
		return;
	}

    float flSpotAtten = flConeToDirection * lightData.SpotLightInnerOuterConeCosines.z;
    float flLightFalloff = CalculateDistanceFalloff(flDistToLightSq, lightData.FalloffParams.xyzw, 1.0);

    [branch]
	if ( lightData.HasLightCookie() )
	{
		// Light cookie
		float3 vPositionTextureSpace = Position3WsToShadowTextureSpace( f.vPositionWs.xyz, lightData.WorldToLightCookie );
		float4 vCookieSample = lightData.SampleLightCookie( vPositionTextureSpace.xy );
		float3 vCookieColor = vCookieSample.rgb * vCookieSample.a;

		// If baked, we just want the hue shift, we already have luminance
		if ( bBaked && any(vCookieColor) )
			vCookieColor = normalize( vCookieColor );
			
		vLightColor.rgb *= vCookieColor;
		
		flSpotAtten = 1.0f;
	}

	float flLightMask = bBaked ? 1.0f : flLightFalloff * flSpotAtten;

	float flShadowScalar = 1.0;

	float3 vTransmissiveThickness = 1.0f;

	[branch]
	if ( lightData.HasDynamicShadows() )
	{
		[unroll ( MAX_SHADOW_FRUSTA_PER_LIGHT ) ]
		for( uint i = 0; i < lightData.NumShadowFrusta(); i++ )
		{
			float3 vPositionTextureSpace = Position3WsToShadowTextureSpace( f.vPositionWs.xyz, lightData.WorldToShadow[i] );
			
			[branch]
			if( InsideShadowRegion( vPositionTextureSpace.xyz, lightData.ShadowBounds[i]) )
            {
				flShadowScalar = ComputeShadow( vPositionTextureSpace.xyz );
				
				// Subsurface scattering
				if( lightData.IsTransmissiveEnabled() )
					vTransmissiveThickness = ComputeTransmissiveThickness( f, lightData, vPositionTextureSpace.xyz, vPositionToLightDirWs );
				
				// Cascades
				if( lightData.HasFrustumFeathering() )
				{
					float flDistanceToShadowEdge = DistanceToShadowEdge( vPositionTextureSpace.xy, lightData.ShadowBounds[i] );
					
					flDistanceToShadowEdge = RemapValClamped( flDistanceToShadowEdge, 0.9, 1.0, 0.0, 1.0 );
					if( flDistanceToShadowEdge > 0 )
					{
						float flShadowScalarNext = ComputeShadow( f.vPositionWs.xyz, lightData.WorldToShadow[ i + 1 ], lightData.ShadowBounds[ i + 1 ] );
						flShadowScalar = lerp( flShadowScalar, flShadowScalarNext, flDistanceToShadowEdge );
					}
					break;
				}
				else
					break;
			}
		}
	}

	#if ( !S_TRANSMISSIVE )
		// If we are shadowed and not transmissive, we can skip the rest of the lighting calculations
		if ( flShadowScalar <= 0.0 )
			return;
	#endif

	float3 vDiffuseTerm, vSpecularTerm, vTransmissiveTerm;
	ComputeDiffuseAndSpecularTerms(
		vDiffuseTerm,
		vSpecularTerm,
		vTransmissiveTerm,
		lightData.IsDiffuseEnabled(), 	// bDiffuse
		lightData.IsSpecularEnabled(), 	// bSpecular
		lightData.IsTransmissiveEnabled(), // bTransmissive
		f,
		vPositionToLightDirWs.xyz,
		vPositionToCameraDirWs.xyz,
		vDiffuseExponent.xy,
		flNDotL );
	
	vDiffuse.rgb 	+= vDiffuseTerm.rgb  * flShadowScalar * flLightMask * vLightColor.rgb;
    vSpecular.rgb 	+= vSpecularTerm.rgb * flShadowScalar * flLightMask * vLightColor.rgb;
    vTransmissive.rgb += vTransmissiveTerm.rgb * f.vTransmissiveMask.rgb * vTransmissiveThickness.rgb * flLightMask * vLightColor.rgb;
}

//---------------------------------------------------------------------------------------------------------------------------------------------------------
void ComputeDirectLighting( inout LightingTerms_t o, const FinalCombinerInput_t f )
{
	o.vDiffuse 		= float3( 0.0, 0.0, 0.0 );
	o.vSpecular 	= float3( 0.0, 0.0, 0.0 );
	o.vTransmissive = float3( 0.0, 0.0, 0.0 );

	ClusterRange lightRange = Cluster::Query( ClusterItemType_Light, f.vPositionWs );

	[loop]
	for ( uint i = 0; i < lightRange.Count; i++ )
	{
		const uint index = Cluster::LoadItem( lightRange, i );
		const BinnedLight lightData = DynamicLightConstantByIndex( index );
		ComputeDirectLightingForLight( f, lightData, o.vDiffuse.rgb, o.vSpecular.rgb, o.vTransmissive.rgb );
	}
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
void CalcBakedLightingForLight( const FinalCombinerInput_t finalCombinerInput, int iLightIndex, float flStrength, float3 vPositionToCameraDirWs, inout float3 io_vDiffuse, inout float3 io_vSpecular, inout float3 io_vTransmissive )
{
	[branch]
	if ( flStrength > 0.0001 )
    {
        BinnedLight lightData = BakedIndexedLightConstantByIndex( iLightIndex );

		float3 vDiffuse = 0;
		float3 vSpecular = 0;
		float3 vTransmissive = 0;

		ComputeDirectLightingForLight( finalCombinerInput, lightData, vDiffuse, vSpecular, vTransmissive, true );
		
        io_vDiffuse += vDiffuse.xyz * flStrength;
        io_vSpecular += vSpecular.xyz * flStrength;
        io_vTransmissive += vTransmissive.xyz * flStrength;

	}
}

// https://sms.playstation.com/stories/gdc-2019-indirect-lighting
float NormalizeCubeBrightness( uint iCubeID, float3 vNormalWs, float flIsotropicRoughness, float flTargetLuminanceOfCubemap )
{
	const float flRoughnessBegin = 0.1f;
	const float flNormalizationCeiling = 32.0f;
	const float2 vNormalizationParams = float2( 
		( flNormalizationCeiling - 1.0f ) / ( 1.0f - flRoughnessBegin ),
		flNormalizationCeiling - ( flNormalizationCeiling - 1.0f ) / ( 1.0f - flRoughnessBegin ) );

	// Our cubemaps are pre-filtered, use a roughly blurred mip of them in place of spherical harmonics to do the normalization
	float flMeasuredLuminanceOfCubemap = max( length( SampleEnvironmentMapLevel(vNormalWs, 1.0f, iCubeID) ), 0.001 );

	float flNormalizationMax = flIsotropicRoughness * vNormalizationParams.x + vNormalizationParams.y;
	flNormalizationMax = max(flNormalizationMax, 1.0f);
	return min( flTargetLuminanceOfCubemap / flMeasuredLuminanceOfCubemap, flNormalizationMax );
}

//---------------------------------------------------------------------------------------------------------------------------------------------------------
void CalculateIndirectLighting( inout LightingTerms_t lightingTerms, const FinalCombinerInput_t finalCombinerData )
{
	float3 vNormalTs				= finalCombinerData.vNormalTs;
	float3 vPositionWs				= finalCombinerData.vPositionWs;
	float3 vPositionWithOffsetWs	= finalCombinerData.vPositionWithOffsetWs;
	float3 vTangentUWs				= finalCombinerData.vTangentUWs;
	float3 vTangentVWs				= finalCombinerData.vTangentVWs;
	float2 vRoughness				= finalCombinerData.vRoughness;
	float2 vAnisotropy				= finalCombinerData.vAnisotropy;
	float flRetroReflectivity		= finalCombinerData.flRetroReflectivity;
	float flTwoLobeSpecularRatio	= finalCombinerData.flTwoLobeSpecularRatio;
	float flSSSCurvature			= finalCombinerData.flSSSCurvature;
	float3 vTransmissiveMask		= finalCombinerData.vTransmissiveMask;
	float4 vPositionSS				= finalCombinerData.vPositionSs - float4( g_vViewportOffset, 0, 0 );

	float3 vNormalWs				= ( finalCombinerData.bUseBentNormalsForIndirect ) ? finalCombinerData.vBentNormalWs.xyz : finalCombinerData.vNormalWs;
	float3 vSSSNormalWs				= ( finalCombinerData.bUseBentNormalsForIndirect ) ? finalCombinerData.vBentDiffuseNormalWs.xyz : finalCombinerData.vSSSNormalWs;

	float flIsotropicRoughness		= IsotropicRoughnessFromAnisotropicRoughness( vRoughness.xy );
	float3 vPositionToCameraDirWs	= CalculatePositionToCameraDirWs( vPositionWs.xyz );
	float flNDotV					= ClampToPositive( dot( vPositionToCameraDirWs.xyz, vNormalWs.xyz ) );

	//
	// Screen space ambient occlusion
	//
	#if ( !S_TRANSLUCENT )
    {
        lightingTerms.flDynamicAmbientOcclusion = ScreenSpaceAmbientOcclusion::Sample( vPositionSS );
	}
	#endif

	float flTargetLuminanceOfCubemap = 0.0;

	bool bHasSpecular = false;
	bool bHasBakedLighting = true;
	bool bHasCubeBrightnessNormalization = true;


	if ( LightmappedLight::UsesLightmaps() )
	{
		float3 vLightmapUVW = float3( finalCombinerData.vLightmapUV, 0 );
		float4 vLightIndexFloats = Tex2DArrayS( LightMap( 0 ), g_sPointClamp, vLightmapUVW ).rgba;
		float4 vLightStrengths = Tex2DArrayS( LightMap( 1 ), g_sTrilinearClamp, vLightmapUVW ).rgba;

		// Ambient Highlight Direction (directional lightmap) data
		float3 vIrradiance = Tex2DArrayS( LightMap( 2 ), g_sTrilinearClamp, vLightmapUVW ).rgb;
		float4 vAHDData = Tex2DArrayS( LightMap( 3 ), g_sTrilinearClamp, vLightmapUVW );

		// reconstruct highlight direction
		float2 vHighlightXY = vAHDData.xy * 2 - 1;
		float3 vHighlightDirTs = float3(vHighlightXY, 1 - sqrt(dot(vHighlightXY, vHighlightXY)));

		// reconstruct lighting intensities, in a way that ensures interpolation between texels is linear.
		float fAmbientLuminanceRatio = vAHDData.z;
		
		fAmbientLuminanceRatio = lerp( 1, fAmbientLuminanceRatio, DIRECTIONAL_LIGHTMAP_STRENGTH );
		// Force ambient luminance ratio to 1.0 if directional lightmaps are disabled.
		fAmbientLuminanceRatio = saturate( fAmbientLuminanceRatio + IsLightMapDirectionalityDisabled() );
		
		float3 vAmbientColor = fAmbientLuminanceRatio * vIrradiance;
		float3 vDirectionalColor = (vIrradiance - vAmbientColor) / max( vHighlightDirTs.z, DIRECTIONAL_LIGHTMAP_MINZ );

		// compute AHD lighting
		#if ( PS_INPUT_HAS_TANGENT_BASIS == 1 )
			vIrradiance = vAmbientColor + max( 0, dot( vHighlightDirTs, vNormalTs ) ) * vDirectionalColor;
		#else
			// we cannot rely on the tangent space, so use incident lighting along +z
			vIrradiance = vAmbientColor + (vHighlightDirTs.z * vDirectionalColor);
		#endif

		lightingTerms.flBakedAmbientOcclusion = vAHDData.w;

		vLightStrengths *= vLightStrengths;

		int4 vLightIndices = int4( vLightIndexFloats.xyzw * 255.0 );

		for( int i=0; i<4; i++ )
		{
			int nLightIndex = vLightIndices[i];
			float flShadow = vLightStrengths[i];

			CalcBakedLightingForLight( finalCombinerData, nLightIndex, flShadow, vPositionToCameraDirWs.xyz, lightingTerms.vDiffuse, lightingTerms.vSpecular, lightingTerms.vTransmissive );

		}
		
		flTargetLuminanceOfCubemap = RelativeLuminance( vIrradiance.rgb );

		lightingTerms.vIndirectDiffuse += float3( vIrradiance.xyz );
	}
	else if ( ProbeLight::UsesProbes() )
	{
		// Sample light probe volume
		float3 vAmbientCube[6];
		SampleLightProbeVolume( vAmbientCube, vPositionWs.xyz );

		if ( g_bNonDirectionalDiffuseLighting )
		{
			for ( int a = 0; a < 6; a++ )
			{
				lightingTerms.vIndirectDiffuse.rgb += vAmbientCube[a].rgb;
			}
			lightingTerms.vIndirectDiffuse.rgb *= ( 1.0 / 6.0 );
		}
		else
		{
			#if ( S_TRANSMISSIVE_BACKFACE_NDOTL )
			{
				flTargetLuminanceOfCubemap = RelativeLuminance( SampleIrradiance( vAmbientCube, vNormalWs.xyz ) );
				lightingTerms.vIndirectDiffuse.rgb = SampleIrradiance( vAmbientCube, vNormalWs.xyz );
				lightingTerms.vTransmissive.rgb += SampleIrradiance( vAmbientCube, -vNormalWs.xyz );
			}
			#elif ( S_SUBSURFACE_SCATTERING == SUBSURFACE_SCATTERING_PREINTEGRATED )
			{
				float3 vNormalR = normalize( lerp( finalCombinerData.vNormalWs.xyz, vNormalWs, g_vAmbientNormalSoftness.r * finalCombinerData.flSSSMask ) );
				float3 vNormalG = normalize( lerp( finalCombinerData.vNormalWs.xyz, vNormalWs, g_vAmbientNormalSoftness.g * finalCombinerData.flSSSMask ) );
				float3 vNormalB = normalize( lerp( finalCombinerData.vNormalWs.xyz, vNormalWs, g_vAmbientNormalSoftness.b * finalCombinerData.flSSSMask ) );

				lightingTerms.vIndirectDiffuse.r = SampleIrradiance( vAmbientCube, vNormalR.xyz ).r;
				lightingTerms.vIndirectDiffuse.g = SampleIrradiance( vAmbientCube, vNormalG.xyz ).g;
				lightingTerms.vIndirectDiffuse.b = SampleIrradiance( vAmbientCube, vNormalB.xyz ).b;

				flTargetLuminanceOfCubemap = RelativeLuminance( SampleIrradiance( vAmbientCube, vNormalWs.xyz ) );
			}
			#else
			{
				// Cheap version (not using 6-tap vAmbientCube)
				#if ( S_SUBSURFACE_SCATTERING )
				{
					lightingTerms.vIndirectDiffuse.rgb = SampleLightProbeVolume( vPositionWs.xyz, vSSSNormalWs.xyz );

					flTargetLuminanceOfCubemap = RelativeLuminance( lightingTerms.vIndirectDiffuse.rgb );
				}
				#else
				{
					lightingTerms.vIndirectDiffuse.rgb = SampleLightProbeVolume( vPositionWs.xyz, vNormalWs.xyz );

					flTargetLuminanceOfCubemap = RelativeLuminance( lightingTerms.vIndirectDiffuse.rgb );
				}
				#endif
			}
			#endif
		}

		int4 vLightIndices;
		float4 vLightStrengths;
		SampleLightProbeVolumeIndexedDirectLighting( vLightIndices, vLightStrengths, vPositionWs.xyz );

		for( int i=0; i<4; i++ )
		{
			int nLightIndex = vLightIndices[i];
			float flShadow = vLightStrengths[i];

			CalcBakedLightingForLight( finalCombinerData, nLightIndex, flShadow, vPositionToCameraDirWs.xyz, lightingTerms.vDiffuse, lightingTerms.vSpecular, lightingTerms.vTransmissive );
		}
	}
	else
	{
		bHasBakedLighting = false;
		bHasCubeBrightnessNormalization = false;
		lightingTerms.vIndirectDiffuse.rgb = lerp( 1.0f, AmbientLightColor.rgb, AmbientLightColor.a ) ;
	}

    //
    // Add DDGI indirect lighting
	// This is done after lightmaps/probes because those actually calculate direct lighting on this block :^(
    //
	if ( DDGI::IsEnabled() )
	{
		DDGIVolume ddgiVolume = DDGI::GetVolume( vPositionWs );
		if ( ddgiVolume.IsValid() )
		{
			float3 ddgiIrradiance = DDGI::Evaluate( ddgiVolume, vPositionWs, vNormalWs, vPositionToCameraDirWs.xyz );
			lightingTerms.vIndirectDiffuse.rgb = ddgiIrradiance;

			bHasBakedLighting = true;
			bHasCubeBrightnessNormalization = true;

			flTargetLuminanceOfCubemap = RelativeLuminance( ddgiIrradiance );
		}
	}

	//
	// Apply specular from cube maps
	//
	bHasSpecular = true;

	{
		float3 vCubeMapTexel_Diffuse = float3( 0.0, 0.0, 0.0 );
		float3 vCubeMapTexel_Specular = float3( 0.0, 0.0, 0.0 );

		float2 vSQRTRoughness = sqrt( vRoughness.xy );

		#if ( S_ANISOTROPIC_GLOSS )
        {
            vSQRTRoughness = sqrt( max( vRoughness.x, vRoughness.y ) );
		}
		#endif
		
        float flDistAccumulated = 0;

		ClusterRange envRange = Cluster::Query( ClusterItemType_EnvMap, vPositionWs );

		float2 vLevel = vSQRTRoughness.xy;
		
		for ( uint i = 0; i < envRange.Count; i++ )
		{
			const uint index = Cluster::LoadItem( envRange, i );

			const float3 vCubePos = mul( float4( vPositionWs.xyz, 1.0 ), EnvMapWorldToLocal( index ) ).xyz;

			const float flEdgeFeathering = EnvMapFeathering( index );

			const float3 vEnvMapMin = EnvMapBoxMins(index);
			const float3 vEnvMapMax = EnvMapBoxMaxs(index);

			const float3 vIntersectA = min( ( vCubePos - vEnvMapMin ), ( vEnvMapMax - vCubePos ) ) ;
			const float3 vIntersectB = min( ( vCubePos - vEnvMapMax ), ( vEnvMapMin - vCubePos ) ) ;

			const float flDistance = min(
				min( vIntersectA.x, min( vIntersectA.y, vIntersectA.z ) ),
				min( -vIntersectB.x, -min( vIntersectB.y, vIntersectB.z ) )
			) + 0.5f; // Add half unit to avoid edge artifacts

			// Branch, but better than sampling all cubes
			if( flDistance + max( flEdgeFeathering, 0.0f ) < 0.0 )
				continue;

			float3 vParallaxReflectionCubemapLocal = CalcParallaxReflectionCubemapLocal( vPositionWs, vNormalWs, vAnisotropy, flRetroReflectivity, vTangentUWs, vTangentVWs, index );

			//---------------------------------------------------------------------------------------------------------------------------------------------------------
			// Specular Environment Maps
			//---------------------------------------------------------------------------------------------------------------------------------------------------------
			float3 vCubeMapTexel = 0.0f;

			#if ( S_CLOTH_SHADING )
			{
				// For cloth shading, roughness needs be very low to fit with the specular shading.  The power here is arbitrary, based on look
				vLevel /= vSQRTRoughness.xy;
				vLevel *= pow( flIsotropicRoughness, 0.125 );
			}
			#endif

			float3 vNormalWarpWs = normalize( lerp( vParallaxReflectionCubemapLocal.xyz, vNormalWs.xyz, vLevel.x ) ); // Used to deal with specular aliasing
			vCubeMapTexel = SampleEnvironmentMapLevel( vNormalWarpWs.xyz, vLevel.x, index );

			// Apply BRDFs
			#if (S_CLOTH_SHADING)
            {
				float3 vHalfAngleDirWs = normalize(vNormalWs.xyz + vPositionToCameraDirWs.xyz);
                float flNdotH = dot(vHalfAngleDirWs.xyz, vNormalWs.xyz);
                vCubeMapTexel *= ComputeCharlieSheenBRDF(flIsotropicRoughness, 1, flNDotV, flNdotH);
            }
			#else
            {
                vCubeMapTexel *= CalcBRDFReflectionFactor(flNDotV, flIsotropicRoughness, finalCombinerData.vSpecularColor);
            }
			#endif

			// Two lobe specular has different logic
			#if ( S_TWO_LOBE_SPECULAR )
			{
				// Glossy lobe
				vNormalWarpWs = normalize( lerp( vParallaxReflectionCubemapLocal.xyz, vNormalWs.xyz, vLevel.y ) );
				float3 vCubeMapTexelGlossy = SampleEnvironmentMapLevel( vNormalWarpWs.xyz, vLevel.y, index );
				vCubeMapTexelGlossy *= CalcBRDFReflectionFactor( flNDotV, vRoughness.y, finalCombinerData.vSpecularColor );
				
			}
			#endif

			if( bHasCubeBrightnessNormalization )
				vCubeMapTexel *= NormalizeCubeBrightness( index, vNormalWs, vRoughness.x, flTargetLuminanceOfCubemap );

			vCubeMapTexel_Specular = lerp( vCubeMapTexel_Specular, vCubeMapTexel, 1.0 - flDistAccumulated );

			//---------------------------------------------------------------------------------------------------------------------------------------------------------
			// Diffuse IBL
			//---------------------------------------------------------------------------------------------------------------------------------------------------------
			{
				const float3 vPositionCubemapLocal 		= mul( float4( vPositionWs.xyz, 1.0f ), EnvMapWorldToLocal( index ) ).xyz;
				const float3 vReflectionCubemapLocal 	= mul( float4( vNormalWs.xyz, 0.0f ), 	EnvMapWorldToLocal( index ) ).xyz;

                // Sam: Avoid using parallax for diffuse IBLs, it's causing issues with non-uniform scaled envmaps for minimal gains
                // https://files.facepunch.com/sampavlovic/1b1711b1/SMr1GfypB3.png
                const float3 vDiffuseIBLNormal = vReflectionCubemapLocal; //CubeMapBoxProjection(vReflectionCubemapLocal.xyz, vPositionCubemapLocal.xyz, EnvMapBoxMins(index).xyz, EnvMapBoxMaxs(index).xyz);
				float3 vCubeMapTexelDiffuse = SampleEnvironmentMapLevel( vDiffuseIBLNormal.xyz, 1.0f, index );

				// Apply from the normal warp if we have SSS
				#if ( S_SUBSURFACE_SCATTERING == SUBSURFACE_SCATTERING_PREINTEGRATED )
				{
					float3 vNormalR = normalize( lerp( vDiffuseIBLNormal.xyz, vNormalWs.xyz, g_vAmbientNormalSoftness.r * finalCombinerData.flSSSMask ) );
					float3 vNormalG = normalize( lerp( vDiffuseIBLNormal.xyz, vNormalWs.xyz, g_vAmbientNormalSoftness.g * finalCombinerData.flSSSMask ) );
					float3 vNormalB = normalize( lerp( vDiffuseIBLNormal.xyz, vNormalWs.xyz, g_vAmbientNormalSoftness.b * finalCombinerData.flSSSMask ) );
					
					vCubeMapTexelDiffuse.r = SampleEnvironmentMapLevel( vNormalR.xyz, 1.0f, index ).r;
					vCubeMapTexelDiffuse.g = SampleEnvironmentMapLevel( vNormalG.xyz, 1.0f, index ).g;
					vCubeMapTexelDiffuse.b = SampleEnvironmentMapLevel( vNormalB.xyz, 1.0f, index ).b;
				}
				#endif

				if( !bHasBakedLighting )
					vCubeMapTexel_Diffuse = lerp( vCubeMapTexel_Diffuse, vCubeMapTexelDiffuse, 1.0 - flDistAccumulated );
			}

			//---------------------------------------------------------------------------------------------------------------------------------------------------------

			flDistAccumulated += RemapValClamped( flDistance, min( -flEdgeFeathering, 0.0f ), max( -flEdgeFeathering, 0.0f ), 0.0, 1.0 );

			// Keep iterating until we've accumulated enough to fill this pixel
			if( flDistAccumulated >= 1.0 )
				break;
		}

        //
        // Dynamic Reflections
        //
		if( DynamicReflections::IsEnabled() )
        {
            float4 vDynamicReflection = DynamicReflections::Sample( vPositionSS.xy, vSQRTRoughness.x );
			float flCompositeConfidence = vDynamicReflection.a;
			vDynamicReflection.rgb *= CalcBRDFReflectionFactor( flNDotV, flIsotropicRoughness, finalCombinerData.vSpecularColor );
			vCubeMapTexel_Specular.rgb = lerp( vCubeMapTexel_Specular.rgb, vDynamicReflection.rgb, flCompositeConfidence );
		}

		if( bHasSpecular )
			lightingTerms.vIndirectSpecular.rgb += vCubeMapTexel_Specular.rgb;
		
		if( !bHasBakedLighting )
			lightingTerms.vIndirectDiffuse.rgb = lerp( vCubeMapTexel_Diffuse.rgb, lightingTerms.vIndirectDiffuse.rgb, AmbientLightColor.w );
	}
	
	// Apply indirect transmissive lighting
	lightingTerms.vTransmissive.rgb += vTransmissiveMask.rgb * lightingTerms.vIndirectDiffuse.rgb;
	
	//
	// Setup final debug variables
	// Tools Vis
	//
	if ( LightmappedLight::UsesLightmaps() || ProbeLight::UsesProbes() )
	{
		float flTexelMod = 1;

		if ( g_bShowLightmapTexels && LightmappedLight::UsesLightmaps() )
		{
			flTexelMod = GetLightmapUVCheckerboard( finalCombinerData.vLightmapUV.xy );
		}
		
		if ( g_bShowLPVVoxels && ProbeLight::UsesProbes() )
		{
			flTexelMod = GetLightProbeUVWCheckerboard( vPositionWs );
		}

		lightingTerms.vIndirectSpecular.rgb *= flTexelMod;
		lightingTerms.vIndirectDiffuse.rgb *= flTexelMod;
		lightingTerms.vSpecular.rgb *= flTexelMod;
		lightingTerms.vDiffuse.rgb *= flTexelMod;
	}
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// Sbox
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
float HenyeyGreenstein(float LoV, float inG)
{
	return (1.-inG * inG)/(pow(1.+inG*inG - 2.0 * inG*LoV, 1.5)*4.0* M_PI);
}

#endif
