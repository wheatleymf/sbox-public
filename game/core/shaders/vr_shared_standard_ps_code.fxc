// Copyright (c) Valve Corporation, All rights reserved. ======================================================================================================
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// These functions are an attempt to standardize the lighting models across HLVR scene shaders, with the goal of accelerating shader authoring and
// homogenizing lighting calculations and making code extension easier.
//
// PS_SharedStandardProcessing or PS_ProcessCommonData should be called at the top of all standard type pixel shaders and sets up a common structure that is used to communicate to our standardized
// final combiner shader. Custom work can be done to modify attributes in the FinalCombinerInput_t after this is called.
//
// PS_FinalCombiner should be called at the end and works on the FinalCombinerInput_t data only. 
// This does lighting, tonemapping, etc. in a standardized way.
//
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

#ifndef VR_SHARED_PS_CODE_FXC
#define VR_SHARED_PS_CODE_FXC


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Common Render States
//
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

#if !defined( DEPTH_STATE_ALREADY_SET )
	#define DEPTH_STATE_ALREADY_SET

	RenderState( DepthEnable, true );
	RenderState( DepthFunc, GREATER_EQUAL );

	#if ( S_TRANSLUCENT )
		RenderState( DepthWriteEnable, false );
	#else
		RenderState( DepthWriteEnable, true );
	#endif

#endif

#if !defined( BLEND_MODE_ALREADY_SET )
	#define BLEND_MODE_ALREADY_SET

	#if ( S_TRANSLUCENT )
		RenderState( BlendEnable, true );
		RenderState( SrcBlend, SRC_ALPHA );

		#if ( S_ADDITIVE_BLEND )
			RenderState( DstBlend, ONE );
		#else
			RenderState( DstBlend, INV_SRC_ALPHA );
		#endif
		
	#elif ( S_ALPHA_TEST )
        RenderState(AlphaToCoverageEnable, true);
		
	#endif
#endif

#if ( D_OPAQUE_FADE )
	RenderState( AlphaToCoverageEnable, true );
#endif

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "vr_common_ps_code.fxc"
#include "common_samplers.fxc"
#include "vr_detail_texture.fxc"

#define MINIMAL_MATERIAL
#include "common/classes/Decals.hlsl"

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Common Textures & Attributes
//
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

//
// Color and translucency
//
CreateInputTexture2D( TextureColor, Srgb, 8, "", "_color", "Color/10", Default3( 1.0, 1.0, 1.0 ) );
CreateInputTexture2D( TextureTranslucency, Linear, 8, "", "_trans", "Translucent,15", Default3( 1.0, 1.0, 1.0 ) );

#ifndef COLOR_SAMPLER_DEFINED
	#if ( S_TRANSLUCENT )
		Texture2D g_tColor < Channel( RGB, AlphaWeighted( TextureColor, TextureTranslucency ), Srgb );
															  Channel( A, Box( TextureTranslucency ), Linear );
															  OutputFormat( BC7 ); SrgbRead( true ); >;
	#elif ( S_ALPHA_TEST )
		Texture2D g_tColor < Channel( RGB, AlphaWeighted( TextureColor, TextureTranslucency ), Srgb );
															  Channel( A, PreserveCoverage( TextureTranslucency ), Linear );
															  OutputFormat( BC7 ); SrgbRead( true ); > ;
	#elif ( S_SPECULAR && !S_METALNESS_TEXTURE ) // this condition is just to maintain backwards compatibility with old vr_standard
		Texture2D g_tColor1 < Channel( RGB, Box( TextureColor ), Srgb );
															   OutputFormat( DXT1 ); SrgbRead( true ); >;

		#define g_tColor g_tColor1
	#else
		Texture2D g_tColor2 < Channel( RGB, Box( TextureColor ), Srgb );
															   OutputFormat( DXT1 ); SrgbRead( true ); >;
		#define g_tColor g_tColor2
	#endif
#endif

//
// Normal map and gloss
//

#ifdef ENABLE_NORMAL_MAPS
	CreateInputTexture2D( TextureNormal, Linear, 8, "NormalizeNormals", "_normal", "Normal,20", Default3( 0.5, 0.5, 1.0 ) );
	CreateInputTexture2D( TextureBentNormal, Linear, 8, "NormalizeNormals", "_bentnormal", "Normal/20", Default3( 0.5, 0.5, 1.0 ) );
	CreateInputTexture2D( TextureRoughness, Linear, 8, "Inverse", "_rough", "Roughness,23/10", Default3( 0.5, 0.5, 0.5 ) );

	#if ( S_ANISOTROPIC_GLOSS )
		// Pack normal & roughness into RG channels of two separate textures, for quality
		Texture2D g_tNormal < Channel( RG, HemiOctIsoRoughness_RG_B( TextureNormal, TextureRoughness ), Linear ); OutputFormat( ATI2N ); SrgbRead( false ); > ;
		Texture2D g_tAnisoGloss < Channel( RG, AnisoRoughness_RG( TextureNormal, TextureRoughness ), Linear ); OutputFormat( ATI2N ); SrgbRead( false ); > ;
	#else
		// Doesn't store anisotropic roughness to allow the compressor to do a better job.
		Texture2D g_tNormal < Channel( RGBA, HemiOctIsoRoughness_RG_B( TextureNormal, TextureRoughness ), Linear ); OutputFormat( BC7 ); SrgbRead( false ); > ;
	#endif
	
	Texture2D g_tBentNormal < Channel( RG, HemiOctIsoRoughness_RG_B( TextureBentNormal ), Linear );  OutputFormat( ATI2N ); SrgbRead( false ); >;

	float g_flNormalMapScaleFactor < Default( 1.0 ); Range( 0.0, 1.0 ); UiGroup( "Normal" ); >;
	float g_flRoughnessScaleFactor < Default( 1.0 ); Range( 0.0, 2.0 ); UiGroup( "Roughness" ); >;
#endif

//
// Self Illumination
//
#if ( S_SELF_ILLUM )
	CreateInputTexture2D( TextureSelfIllumMask, Srgb, 8, "", "_selfillum", "Self Illum,60/10", Default3( 0.0, 0.0, 0.0 ) );
	Texture2D g_tSelfIllumMask < Channel( RGB, Box( TextureSelfIllumMask ), Srgb ); OutputFormat( DXT1 ); SrgbRead( true ); >;

	TextureAttribute( LightSim_SelfIllumMaskTexture, g_tSelfIllumMask );
	
	Float3Attribute( LightSim_SelfIllumTint, g_vSelfIllumTint );
	FloatAttribute( LightSim_SelfIllumScale, g_flSelfIllumScale );

	float3 g_vSelfIllumTint < UiType( Color ); Default3( 1.0, 1.0, 1.0 ); UiGroup( "Self Illum/20" ); >;
	float g_flSelfIllumBrightness < Default( 0.0 ); Range( -10.0, 10.0 ); UiGroup( "Self Illum" ); >;
	float g_flSelfIllumScale < Default( 1.0 ); Range( 0.0, 16.0 ); UiGroup( "Self Illum/30" ); >;
	float2 g_vSelfIllumOffset < Default2( 0.0, 0.0 ); UiGroup( "Self Illum/35" ); >;
	float2 g_vSelfIllumScrollSpeed < Default2( 0.0, 0.0 ); Range2( -10.0, -10.0, 10.0, 10.0 ); UiGroup( "Self Illum/40" ); >;
	float g_flSelfIllumAlbedoFactor < Default( 1.0 ); Range( 0.0, 1.0 ); UiGroup( "Self Illum/50" );  >;
#endif

//
// Tint Mask
//
#if ( S_TINT_MASK )
	CreateInputTexture2D( TextureTintMask, Linear, 8, "", "_mask", "Color", Default3( 1.0, 1.0, 1.0 ) );

	Texture2D g_tTintMask < Channel( R, Box( TextureTintMask ), Linear ); OutputFormat( ATI1N ); SrgbRead( false ); Filter( TRILINEAR ); >;
	TextureAttribute( LightSim_TintMaskTextureR, g_tTintMask );
#endif

//
// Ambient Occlusion
//
CreateInputTexture2D( TextureAmbientOcclusion, Linear, 8, "", "_ao", "Ambient Occlusion,40/10", Default3( 1.0, 1.0, 1.0 ) );
#if !defined( AMBIENT_OCCLUSION_IN_COLOR )
	Texture2D g_tAmbientOcclusion < Channel( R, Box3( TextureAmbientOcclusion ), Linear ); OutputFormat( ATI1N ); SrgbRead( false ); >;
#endif


//
// UV2 Controls
//
#if ( S_UV2_CONTROLS )
	bool g_bUseSecondaryUvForSelfIllum < Default( 0.0 ); UiGroup( "Self Illum/100" ); >;
	bool g_bUseSecondaryUvForTintMask < Default( 0.0 ); UiGroup( "Color/101" ); >;
	bool g_bUseSecondaryUvForAmbientOcclusion < Default( 1.0 ); UiGroup( "Ambient Occlusion/100" ); >;
	bool g_bUseSecondaryUvForDetailMask < Default( 1.0 ); UiGroup( "Detail Texture/180" ); >;
#endif

//
// Metalness
//
#if ( S_METALNESS_TEXTURE )
	CreateInputTexture2D( TextureMetalness, Linear, 8, "", "_metal", "Metalness,27/10", Default3( 0.0, 0.0, 0.0 ) );

	#if !defined( METALNESS_IN_COLOR )
		CreateInputTexture2D( TextureRetroReflectiveMask, Linear, 8, "", "_mask", "Retro-Reflective,29/10", Default3( 1.0, 1.0, 1.0 ) );
		Texture2D g_tMetalness <
			Channel( G, Box( TextureMetalness ), Linear );
			#if ( S_RETRO_REFLECTIVE )
				Channel( R, Box( TextureRetroReflectiveMask ), Linear );
			#endif
			OutputFormat( DXT1 );
			SrgbRead( false ); >;
	#endif
#else
	float g_flMetalness < Default( 0.0 ); Range( 0.0, 1.0 ); UiGroup( "Metalness,27/20" ); >;
	float g_flRetroReflectivity < Default( 1.0 ); Range( 0.0, 1.0 ); UiGroup( "Retro-Reflective,29/20" ); >;
#endif

// Detail Texture
#if ( S_DETAIL_TEXTURE )
	CreateInputTexture2D( TextureDetail, Linear, 8, "Mod2XCenter", "_detail", "Detail Texture,80/10", Default4( 1.0, 1.0, 1.0, 1.0 ) );
	CreateInputTexture2D( TextureNormalDetail, Linear, 8, "NormalizeNormals", "_normal", "Detail Texture,80/10", Default3( 0.5, 0.5, 1.0 ) );
	CreateInputTexture2D( TextureDetailMask, Linear, 8, "", "_detailmask", "Detail Texture,80/40", Default4( 1.0, 1.0, 1.0, 1.0 ) );

	Texture2D g_tDetail < Channel( RGB, Box( TextureDetail ), Linear ); OutputFormat( BC7 ); SrgbRead( false ); >;
	Texture2D g_tNormalDetail < Channel( RG, HemiOctIsoRoughness_RG_B( TextureNormalDetail ), Linear ); OutputFormat( ATI2N ); SrgbRead( false ); >;
	Texture2D g_tDetailMask < Channel( R, Box( TextureDetailMask ), Linear ); OutputFormat( ATI1N ); SrgbRead( false ); >;

	float g_flDetailBlendFactor < Default( 1.0 ); Range( 0.0, 1.0 ); UiGroup( "Detail Texture,80/20" ); >;
	float g_flDetailBlendToFull < Default( 0.0 ); Range( 0.0, 1.0 ); UiGroup( "Detail Texture,80/50" ); >;
#endif

//
// Wrinkle
//
// Fixme: should pack each squish/stretch pair into a texture array
// Would need to sort out some drama in the texture compiler first
//
CreateInputTexture2D( TextureSquishColor, Srgb, 8, "", "_color", "Color/11", Default3( 1.0, 1.0, 1.0 ) );
CreateInputTexture2D( TextureStretchColor, Srgb, 8, "", "_color", "Color/12", Default3( 1.0, 1.0, 1.0 ) );
CreateInputTexture2D( TextureSquishNormal, Linear, 8, "NormalizeNormals", "_normal", "Normal/21", Default3( 0.5, 0.5, 1.0 ) );
CreateInputTexture2D( TextureStretchNormal, Linear, 8, "NormalizeNormals", "_normal", "Normal/22", Default3( 0.5, 0.5, 1.0 ) );
CreateInputTexture2D( TextureSquishAmbientOcclusion, Linear, 8, "", "_ao", "Ambient Occlusion/11", Default3( 1.0, 1.0, 1.0 ) );
CreateInputTexture2D( TextureStretchAmbientOcclusion, Linear, 8, "", "_ao", "Ambient Occlusion/12", Default3( 1.0, 1.0, 1.0 ) );
Texture2D g_tSquishColor < Channel( RGB, Box( TextureSquishColor ), Srgb ); OutputFormat( DXT1 ); SrgbRead( true ); >;
Texture2D g_tStretchColor < Channel( RGB, Box( TextureStretchColor ), Srgb ); OutputFormat( DXT1 ); SrgbRead( true ); >;
Texture2D g_tSquishNormal < Channel( RGBA, HemiOctIsoRoughness_RG_B( TextureSquishNormal, TextureRoughness ), Linear ); OutputFormat( BC7 ); SrgbRead( false ); >;
Texture2D g_tStretchNormal < Channel( RGBA, HemiOctIsoRoughness_RG_B( TextureStretchNormal, TextureRoughness ), Linear ); OutputFormat( BC7 ); SrgbRead( false ); >;
Texture2D g_tSquishAmbientOcclusion < Channel( R, Box3( TextureSquishAmbientOcclusion ), Linear ); OutputFormat( ATI1N ); SrgbRead( false ); >;
Texture2D g_tStretchAmbientOcclusion < Channel( R, Box3( TextureStretchAmbientOcclusion ), Linear ); OutputFormat( ATI1N ); SrgbRead( false ); >;

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Common Params
//
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

#if ( S_TRANSLUCENT )
	BoolAttribute( translucent, true );
	float g_flOpacityScale < Default( 1.0 ); Range( 0.0, 1.0 ); UiGroup( "Translucent" ); >;
#endif

#if ( S_ALPHA_TEST )
	BoolAttribute( alphatest, true );
	float g_flAlphaTestReference < Default( 0.5 ); Range( 0.01, 0.99 ); UiGroup( "Translucent" ); >;
	float g_flAntiAliasedEdgeStrength < Default( 1.0 ); Range( 0.0, 1.0 ); UiGroup( "Translucent" ); >;
#endif

BoolAttribute( DoNotCastShadows, F_DO_NOT_CAST_SHADOWS ? true : false );
BoolAttribute( SupportsMappingDimensions, true );

TextureAttribute( LightSim_DiffuseAlbedoTexture, g_tColor );
TextureAttribute( RepresentativeTexture, g_tColor );

BoolAttribute( renderbackfaces, F_RENDER_BACKFACES ? true : false );
BoolAttribute( ShadowFastPath, true );

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
float4 SampleColorTexture( float2 vTextureCoords )
{
	return Tex2DS( g_tColor, g_sAniso, vTextureCoords.xy );
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
#if ( S_TINT_MASK )
float SampleTintMaskTexture( float2 vTextureCoords )
{
	float4 mask;

	mask = Tex2DS( g_tTintMask, g_sAniso, vTextureCoords.xy );

	return mask.r;
}
#endif


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Common Pixel Shader Code
//
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
#ifdef SHARED_STANDARD_PS_INPUT_DEFINED

FinalCombinerInput_t PS_SharedStandardProcessing( const PS_INPUT i )
{
	FinalCombinerInput_t o;

	o = PS_CommonProcessing( i );

	float4 vColorTexel = SampleColorTexture( i.vTextureCoords.xy );

	//
	// Alpha test
	//
	#if ( S_ALPHA_TEST )
	{
		float eps = 1/255.0f;
        
        o.flOpacity = vColorTexel.a * o.flOpacity;
		
        // Clip first to try to kill the wave if we're in an area of all zero
        clip(o.flOpacity - eps);

		o.flOpacity = AdjustOpacityForAlphaToCoverage( o.flOpacity, g_flAlphaTestReference, g_flAntiAliasedEdgeStrength, i.vTextureCoords.xy );
		
        if (g_nMSAASampleCount == 1)
            OpaqueFadeDepth((o.flOpacity + 0.5f + eps) * 0.5f, i.vPositionSs.xy);
        else
            clip(o.flOpacity - 0.000001);
	}
	#endif

	//
	// Wrinkle color
	//
	#if ( S_WRINKLE )
	{
		float4 vWrinkleColorTexel = ( o.flWrinkle < 0.0 ) ?
			Tex2DS( g_tSquishColor, g_sAniso, i.vTextureCoords.xy ).rgba :
			Tex2DS( g_tStretchColor, g_sAniso, i.vTextureCoords.xy ).rgba;

		vColorTexel.rgb = lerp( vColorTexel.rgb, vWrinkleColorTexel.rgb, abs( o.flWrinkle ) );
	}
	#endif

	//
	// Albedo
	//
	float3 vAlbedo;
	#if ( S_TINT_MASK )
	{
		float2 vTintMaskUVs = GetUVDefault1( g_bUseSecondaryUvForTintMask, i.vTextureCoords );
		float flTintMask = SampleTintMaskTexture( vTintMaskUVs.xy );
		vAlbedo = lerp( vColorTexel.rgb, vColorTexel.rgb * i.vVertexColor.rgb, flTintMask );
	}
	#else
	{
		vAlbedo = vColorTexel.rgb * i.vVertexColor.rgb;
	}
	#endif

	//
	// Ambient Occlusion
	//
	float2 vAmbientOcclusionUVs;
	#if ( S_UV2_DEFAULT_FOR_AO )
	{
		vAmbientOcclusionUVs.xy = GetUVDefault2( g_bUseSecondaryUvForAmbientOcclusion, i.vTextureCoords );
	}
	#else
	{
		vAmbientOcclusionUVs.xy = i.vTextureCoords.xy;
	}
	#endif

	#if defined( AMBIENT_OCCLUSION_IN_COLOR )
		#if ( S_UV2_DEFAULT_FOR_AO ) || defined( METALNESS_IN_COLOR )
			#error Invalid Combination
		#endif

		o.flAmbientOcclusion = vColorTexel.a;
	#else
		o.flAmbientOcclusion = Tex2DS( g_tAmbientOcclusion, g_sTrilinearWrap, vAmbientOcclusionUVs.xy ).r;
	#endif

	//
	// Wrinkle ambient occlusion
	//
	#if ( S_WRINKLE )
	{
		float flWrinkleAmbientOcclusion = ( o.flWrinkle < 0.0 ) ?
			Tex2DS( g_tSquishAmbientOcclusion, g_sTrilinearWrap, vAmbientOcclusionUVs.xy ).r :
			Tex2DS( g_tStretchAmbientOcclusion, g_sTrilinearWrap, vAmbientOcclusionUVs.xy ).r;

		o.flAmbientOcclusion = lerp( o.flAmbientOcclusion, flWrinkleAmbientOcclusion, abs( o.flWrinkle ) );
	}
	#endif

	//
	// Translucency
	//
	#if ( S_TRANSLUCENT )
	{
		o.flOpacity *= vColorTexel.a * g_flOpacityScale;
	}
	#endif


	//
	// Metalness
	//
	float flMetalness = 0.0f;

	#if ( S_METALNESS_TEXTURE )
	{
		#ifdef METALNESS_IN_COLOR
		{
			flMetalness = vColorTexel.a;
		}
		#else
		{
			float4 vMetalnessTexel = Tex2DS( g_tMetalness, g_sTrilinearWrap, i.vTextureCoords.xy );
			flMetalness = vMetalnessTexel.g;

			#if ( S_RETRO_REFLECTIVE )
			{
				o.flRetroReflectivity = vMetalnessTexel.r;
			}
			#endif
		}
		#endif
	}
	#else
	{
		flMetalness = g_flMetalness;
		o.flRetroReflectivity = g_flRetroReflectivity;
	}
	#endif

	//
	// Get detail mask here - needed for normals and albedo
	//
	float flDetailMask = 0.0;
	#if	( S_DETAIL_TEXTURE )
	{
		float2 vDetailMaskUVs = GetUVDefault2( g_bUseSecondaryUvForDetailMask, i.vTextureCoords );
		flDetailMask = max( Tex2DS( g_tDetailMask, g_sAniso, vDetailMaskUVs.xy ).r, g_flDetailBlendToFull ) * g_flDetailBlendFactor;
	}
	#endif

	// 
	// Decode normal and roughness values
	//
	#if defined( ENABLE_NORMAL_MAPS )
	{
		//
		// Normal mapping
		//
		float4 vNormalTexel = Tex2DS( g_tNormal, g_sAniso, i.vTextureCoords.xy );

		#if ( S_WRINKLE )
		{
			float4 vWrinkleNormalTexel = ( o.flWrinkle < 0.0 ) ?
				Tex2DS( g_tSquishNormal, g_sAniso, i.vTextureCoords.xy ).rgba :
				Tex2DS( g_tStretchNormal, g_sAniso, i.vTextureCoords.xy ).rgba;

			vNormalTexel.rgba = lerp( vNormalTexel.rgba, vWrinkleNormalTexel.rgba, abs( o.flWrinkle ) );
		}
		#endif


		float3 vNormalTS = DecodeHemiOctahedronNormal( vNormalTexel.rg );

		#if ( S_ANISOTROPIC_GLOSS )
		{
			float4 vGlossTexel = Tex2DS( g_tAnisoGloss, g_sAniso, i.vTextureCoords.xy );

			o.vRoughness = vGlossTexel.rg;
		}
		#else
		{
			o.vRoughness = vNormalTexel.bb;
		}
		#endif

		// Scale roughness
		o.vRoughness = pow( o.vRoughness, g_flRoughnessScaleFactor );	

		//
		// Optional scale down
		//
		#if ( S_SCALE_NORMAL_MAP )
		{
			vNormalTS = lerp( float3( 0.0f, 0.0f, 1.0f ), vNormalTS, g_flNormalMapScaleFactor );
			vNormalTS = normalize( vNormalTS );
		}
		#endif

		#if ( !S_UNLIT )
		{
			//
			// Blend in detail normal texture
			//
			#if ( ( S_DETAIL_TEXTURE == 3 ) || ( S_DETAIL_TEXTURE == 4 ) )
			{
				float4 vNormalDetailTexel = Tex2DS( g_tNormalDetail, g_sAniso, i.vDetailTextureCoords.xy );
				float3 vNormalDetailTs = DecodeHemiOctahedronNormal( vNormalDetailTexel.rg );
				vNormalTS.xyz = ApplyDetailNormal( vNormalTS.xyz, vNormalDetailTs.xyz, flDetailMask );
			}
			#endif

			PS_CommonTransformNormal( i, o, vNormalTS );
		}
		#endif

		#if ( S_USE_BENT_NORMALS )
		{
			float4 vBentNormalTexel = Tex2DS( g_tBentNormal, g_sAniso, i.vTextureCoords.xy );
			float3 vBentNormalTs = DecodeHemiOctahedronNormal( vBentNormalTexel.rg );
			vBentNormalTs.y = -vBentNormalTs.y;
			float3 vBentNormalWs = normalize( Vec3TsToWs( vBentNormalTs.xyz, i.vNormalWs.xyz, o.vTangentUWs.xyz, o.vTangentVWs.xyz ) );
			float3 vBentShadingNormalTs = vNormalTS.xyz;
			vBentShadingNormalTs.y = -vBentShadingNormalTs.y; // HACK: Tools still generate tangent space the inverted Source1 way where positive y is down. Flipping the normal here to compensate.
			o.vBentNormalWs.xyz = normalize( Vec3TsToWs( vBentShadingNormalTs.xyz, vBentNormalWs.xyz, o.vTangentUWs.xyz, o.vTangentVWs.xyz ) );
			o.bUseBentNormalsForIndirect = true;
		}
		#endif
	}
	#endif
		
	//
	// Self Illum
	//
	#if ( S_SELF_ILLUM )
	{
		float2 vSelfIllumTextureCoords = g_vSelfIllumOffset.xy + GetUVDefault1( g_bUseSecondaryUvForSelfIllum, i.vTextureCoords ) + frac( g_flTime * g_vSelfIllumScrollSpeed.xy );
		float3 vSelfIllumTintScaled = pow( 2.0, g_flSelfIllumBrightness ).xxx * saturate( g_flSelfIllumScale.xxx ) * SrgbGammaToLinear( g_vSelfIllumTint.xyz );
		o.vEmissive = Tex2DS( g_tSelfIllumMask, g_sTrilinearWrap, vSelfIllumTextureCoords.xy ).rgb * vSelfIllumTintScaled.rgb;
		o.vEmissive = lerp( o.vEmissive.rgb, o.vEmissive.rgb * vAlbedo.rgb, g_flSelfIllumAlbedoFactor );
	}
	#endif

	//
	// Detail Texture
	//
	#if ( S_DETAIL_TEXTURE )
	{
		float3 vDetailTexel = Tex2DS( g_tDetail, g_sAniso, i.vDetailTextureCoords.xy ).rgb;

		// Mod2X
		#if ( S_DETAIL_TEXTURE == 1 ) 
		{
			vAlbedo.rgb *= lerp( float3( 1.0, 1.0, 1.0 ), MOD2X_SCALAR * vDetailTexel.rgb, flDetailMask );
		}
		#endif

		// Photoshop Overlay
		#if ( ( S_DETAIL_TEXTURE == 2 ) || ( S_DETAIL_TEXTURE == 4 ) ) 
		{
			vAlbedo.rgb = PhotoshopOverlay( vAlbedo.rgb, vDetailTexel.rgb, flDetailMask );
		}
		#endif
	}
	#endif

	// Decals
	{
		Material material = Material::Init();
		material.WorldPosition = o.vPositionWs;
		material.Albedo = vAlbedo;
		material.Normal = o.vNormalWs;
		material.WorldTangentU = o.vTangentUWs;
		material.WorldTangentV = o.vTangentVWs;		
		material.Roughness = o.vRoughness.x;
		material.AmbientOcclusion = o.flAmbientOcclusion;
		material.Emission = o.vEmissive;
		material.Metalness = flMetalness;

		Decals::Apply( o.vPositionWs, material );

		vAlbedo = material.Albedo;
		o.vNormalWs = material.Normal;
		o.vRoughness.x = material.Roughness;
		o.flAmbientOcclusion = material.AmbientOcclusion;
		o.vEmissive = material.Emission;
		flMetalness = material.Metalness;
	}

	o = CalculateDiffuseAndSpecularFromAlbedoAndMetalness( o, vAlbedo, flMetalness );
	
	// Tool Vis
	{
		o.vTextureCoords = i.vTextureCoords.xy;
	}

	return o;
}

#endif

//-------------------------------------------------------------------------------------------------------------------------------------------------------------

#endif